#!/bin/bash
# This is supposed to be soured, the line above is a hint for vim

. /usr/share/debconf/confmodule

# Initializes context variable
# Variable name is given as first argument
function sdu_context_create() {
	declare -g -A SDU_CONTEXT
	declare -g -A SDU_CONFIG
	SDU_CONTEXT[ACTION]="$1"
	SDU_CONTEXT[PACKAGE]="$2"
	SDU_CONTEXT[CONF_FILE]="$3"
	SDU_CONTEXT[CONF_FILE_TYPE]="$4"
	if [ -n "$5" ];
	then
		SDU_CONTEXT[SERVICE]="$5"
	else
		SDU_CONTEXT[SERVICE]="${SDU_CONTEXT[PACKAGE]}"
	fi
	if [ -n "$6" ];
	then
		SDU_CONTEXT[USER]="$6"
		if [ -n "$7" ];
		then
			SDU_CONTEXT[HOME]="$7"
		else
			SDU_CONTEXT[HOME]="/var/lib/${SDU_CONTEXT[SERVICE]}"
		fi
	else
		# User name and service name are same by default
		SDU_CONTEXT[USER]="${SDU_CONTEXT[SERVICE]}"
		SDU_CONTEXT[HOME]="/var/lib/${SDU_CONTEXT[SERVICE]}"
	fi
}

# Stores VALUE into CONF_FILE in simple KEY=VALUE format
function sdu_store_plain_ooc() {
	local CONF_FILE="$1"
	local KEY="$2"
	local VALUE="$3"

	# Prevents secrets from leaking
	cat << EOF >> "$CONF_FILE"
$KEY=$VALUE
EOF
}

function sdu_store_plain() {
	sdu_store_plain_ooc "${SDU_CONTEXT[CONF_FILE]}" "$@"
	return $?
}

# Stores VALUE into CONF_FILE in toml format
# If TYPE is "string", the value is properly escaped
function sdu_store_toml_ooc() {
	local CONF_FILE="$1"
	local KEY="$2"
	local VALUE="$3"
	local TYPE="$4"

	if [ "$TYPE" = "string" ];
	then
		echo -n "$KEY=\"" >> "$CONF_FILE"
		cat << EOF | perl -pe 'chomp if eof' | sed -e 's/\\/\\\\/' -e 's/"/\\"/' | awk 1 ORS='\\n' >> "$CONF_FILE"
$VALUE
EOF
		echo '"' >> "$CONF_FILE"
	else
		# Prevents secrets from leaking
		cat << EOF >> "$CONF_FILE"
$KEY=$VALUE
EOF
	fi
}

function sdu_store_toml() {
	sdu_store_toml_ooc "${SDU_CONTEXT[CONF_FILE]}" "$@"
	return $?
}

# Internal function
# Retrieves the value of KEY from the database and stores into the CONF_FILE
function sdu_kv() {
	local CONF_FILE="$1"
	local CONF_FILE_TYPE="$2"
	local PACKAGE="$3"
	local KEY="$4"
	local VALUE_TYPE="$5"
	local CONF_KEY="$6"

	if [ -z "$CONF_KEY" ];
	then
		CONF_KEY=$KEY
	fi

	db_get "$PACKAGE/$KEY"
	SDU_CONFIG["$PACKAGE/$KEY"]="$RET"

	sdu_store_${CONF_FILE_TYPE}_ooc "$CONF_FILE" "$CONF_KEY" "$RET" "$VALUE_TYPE"
}

# Reads variable specification from arguments and processes them
# Args have format VAR_NAME[:VAR_TYPE[:RENAME_VAR]]
# If RENAME_VAR is non-empty, it's used instead of VAR_NAME when storing into conf file
# The variable values will be accessible in ${SDU_CONFIG[$PACKAGE/$VAR_NAME]}
function sdu_vars_ooc() {
	local CONF_FILE="$1"
	local CONF_FILE_TYPE="$2"
	local PACKAGE="$3"
	shift
	shift
	shift

	while [ $# -gt 0 ];
	do
		local VAR_NAME="`echo -n "$1" | awk -F ':' '{ print $1; }'`"
		local VAR_TYPE="`echo -n "$2" | awk -F ':' '{ print $2; }'`"
		local VAR_RENAME="`echo -n "$3" | awk -F ':' '{ print $3; }'`"

		sdu_kv "$CONF_FILE" "$CONF_FILE_TYPE" "$PACKAGE" "$VAR_NAME" "$VAR_TYPE" "$VAR_RENAME"

		shift
	done
}

function sdu_vars() {
	sdu_vars_ooc "${SDU_CONTEXT[CONF_FILE]}" "${SDU_CONTEXT[CONF_FILE_TYPE]}" "${SDU_CONTEXT[PACKAGE]}" "$@"
	return $?
}

# Creates user and group with specified user name
function sdu_prepare_user() {
	if [ "${SDU_CONTEXT[ACTION]}" = triggered ];
	then
		true
	else
		adduser --system --group --home "${SDU_CONTEXT[HOME]}" "${SDU_CONTEXT[USER]}"
	fi
}

# Creates parent directory leading to the config file
# Creates the config file with appropriate ownership and permissions
function sdu_prepare_conf() {
	local CONF_FILE="${SDU_CONTEXT[CONF_FILE]}"

	mkdir -p "`dirname "$CONF_FILE"`"
	echo '# Automatically generated - DO NOT MODIFY!' > "$CONF_FILE"
	chmod 640 "$CONF_FILE"
	chgrp "$SERVICE_USER" "$CONF_FILE"
}

# Concats files in CONF_DIR (if existing) and appends to CONF_FILE
# Trick used for services that don't support conf.d natively
function sdu_cat_conf_d() {
	local CONF_DIR=$1

	if [ $# -gt 1 ];
	then
		local CONF_FILE="$2"
		shift
	else
		local CONF_FILE="${SDU_CONTEXT[CONF_FILE]}"
	fi

	if [ -d "$CONF_DIR" ] && [ `ls "$CONF_DIR" | wc -l` -gt 0 ];
	then
		cat "$CONF_DIR"/* >> "$CONF_FILE"
	fi
}

function sdu_restart_if_needed() {
	local SERVICE_NAME=$1
	local ACTION=$2

	if [ "$ACTION" = "triggered" ];
	then
		systemctl restart "$SERVICE_NAME"
	fi
}
